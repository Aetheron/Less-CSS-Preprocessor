<?php
// $Id$

/**
 * Implements hook_menu().
 */
function less_menu() {
  $items = array();
  
  $items['admin/settings/less'] = array(
    'title' => 'LESS settings',
    'description' => 'Administer LESS settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('less_settings'),
    'access arguments' => array('access administration pages'),
    'file' => 'less.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Builds the less cache
 */
function _less_build(&$vars, $hook) {
  
  $css = $vars['css'];

  $less_path = file_directory_path() . '/less';
  
  // Flush compiled LESS files if developer mode is enabled 
  if (variable_get('less_devel', FALSE)) {
    _less_recursive_delete($less_path);
    drupal_set_message(t('LESS files are being regenerated on every request. Remember to <a href="!url">turn off</a> this feature on production websites.', array("!url" => url('admin/settings/less'))), 'status');
  }
  
  foreach ($css as $media => $types) {
    foreach ($types as $type => $files) {

      $files_keys = array_keys($files);
      foreach ($files_keys as $key => $input_file) {

        if (substr($input_file, -5) == '.less') {

          $css_path = $less_path .'/'. dirname($input_file);

          if (!is_dir($css_path)) {
            @mkdir($css_path, 0775, TRUE);
          }

          $output_file = $css_path .'/'. basename($input_file, '.less');
          if (substr($output_file, -4) != '.css') {
            $output_file .= '.css';
          }

          if ((!file_exists($output_file) || filemtime($input_file) > filemtime($output_file))) {
            require_once('lessphp/lessc.inc.php');

            $less = new lessc();

            $contents = drupal_load_stylesheet($input_file, false);

            $base = base_path() . dirname($input_file) .'/';
            _drupal_build_css_path(NULL, $base);
            // Prefix all paths within this CSS file, ignoring external and absolute paths.
            $data = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $contents);

            try {
              $output_data = $less->parse($data);
              file_save_data($output_data, $output_file, FILE_EXISTS_REPLACE);
            }
            catch (Exception $e) {
              $message = 'LESS ERROR: '. $e->getMessage() .', '. $input_file;
              watchdog('LESS', $message, array(), WATCHDOG_ERROR);
              if (user_access('access administration pages')) {
                drupal_set_message($message, 'error');
              }
            }

          }

          if (file_exists($output_file)) {
            array_splice($files_keys, $key, 1, $output_file);
          }

        }

      }

      if (!empty($files)) {
        $css[$media][$type] = array_combine($files_keys, $files);
      }

    }
  }

  $vars['messages'] .= theme('status_messages');

  $vars['css'] = $css;
  $vars['styles'] = drupal_get_css($vars['css']);
}

/**
 * Implements MODULE_preprocess_page().
 */
function less_preprocess_page(&$vars, $hook) {
  _less_build($vars, $hook);
}

/**
 * Implements MODULE_preprocess_maintenance_page().
 */
function less_preprocess_maintenance_page(&$vars, $hook) {
  _less_build($vars, $hook);
}

/**
 * Implements HOOK_enable().
 */
function less_enable() {
  drupal_rebuild_theme_registry();
}

/**
 * Recursively delete a path.
 *
 * Lifted from imagecache, with thanks to dopry/drewish.
 */
function _less_recursive_delete($path) {
  if (is_file($path) || is_dir($path) || is_link($path)) {
    if (is_file($path) || is_link($path)) {
      unlink($path);
    }
    elseif (is_dir($path)) {
      $d = dir($path);
      while (($entry = $d->read()) !== FALSE) {
        if ($entry == '.' || $entry == '..') continue;
        $entry_path = $path .'/'. $entry;
        _less_recursive_delete($entry_path);
      }
      $d->close();
      rmdir($path);
    }
    else {
      watchdog('LESS', 'Unknown file type(%path) stat: %stat ',
                array('%path' => $path,  '%stat' => print_r(stat($path),1)), WATCHDOG_ERROR);
    }
  }
}
